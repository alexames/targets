# embed_binary.cmake
# Embed binary files as C++ code in a static library

include_guard(GLOBAL)

# Embed binary files as C++ code
#
# Creates a static library containing embedded binary data accessible from C++.
# This is useful for embedding assets, configuration files, etc. directly into executables.
#
# Arguments:
#   TARGET: Name of the library target to create (required)
#   FILES: List of binary files to embed (required)
#   NAMESPACE: C++ namespace for the embedded data (optional)
#   OUTPUT_DIR: Directory for generated source files (default: CMAKE_CURRENT_BINARY_DIR)
#
# Note: This is a simplified implementation. For production use, consider using
# CMakeRC (https://github.com/vector-of-bool/cmrc) or a similar solution.
#
# Example:
#   embed_binary(
#       TARGET EmbeddedAssets
#       FILES
#           assets/logo.png
#           assets/config.json
#       NAMESPACE MyApp::Assets
#   )
function(embed_binary)
  set(options)
  set(one_value_args
    TARGET
    NAMESPACE
    OUTPUT_DIR
  )
  set(multi_value_args FILES)

  cmake_parse_arguments(
    PARSE_ARGV 0
    args
    "${options}"
    "${one_value_args}"
    "${multi_value_args}")

  # Validate required arguments
  if(NOT args_TARGET)
    message(FATAL_ERROR "embed_binary: TARGET argument is required")
  endif()

  if(NOT args_FILES)
    message(FATAL_ERROR "embed_binary: FILES argument is required")
  endif()

  # Set defaults
  if(NOT args_OUTPUT_DIR)
    set(args_OUTPUT_DIR "${CMAKE_CURRENT_BINARY_DIR}/_embed_binary/${args_TARGET}")
  endif()

  if(NOT args_NAMESPACE)
    set(args_NAMESPACE "embedded")
  endif()

  # Convert namespace "::" to "_" for C identifiers
  string(REPLACE "::" "_" namespace_prefix "${args_NAMESPACE}")

  # Create output directory
  file(MAKE_DIRECTORY "${args_OUTPUT_DIR}")

  # Generate source files for each embedded file
  unset(generated_sources)
  unset(generated_headers)

  foreach(file_path ${args_FILES})
    # Make path absolute
    cmake_path(IS_ABSOLUTE file_path is_absolute)
    if(NOT is_absolute)
      set(file_path "${CMAKE_CURRENT_SOURCE_DIR}/${file_path}")
    endif()

    # Validate file exists
    if(NOT EXISTS "${file_path}")
      message(FATAL_ERROR "embed_binary: File does not exist: ${file_path}")
    endif()

    # Get filename for variable name
    get_filename_component(filename "${file_path}" NAME)
    string(MAKE_C_IDENTIFIER "${filename}" var_name)

    # Output file paths
    set(output_header "${args_OUTPUT_DIR}/${var_name}.h")
    set(output_source "${args_OUTPUT_DIR}/${var_name}.cpp")

    # Read file as hex
    file(READ "${file_path}" file_contents HEX)

    # Convert hex to C++ array initializer
    string(LENGTH "${file_contents}" hex_length)
    math(EXPR data_length "${hex_length} / 2")

    # Format as comma-separated hex bytes
    set(array_data "")
    string(REGEX MATCHALL ".." hex_bytes "${file_contents}")
    list(LENGTH hex_bytes num_bytes)
    set(counter 0)
    foreach(byte ${hex_bytes})
      if(counter GREATER 0)
        string(APPEND array_data ", ")
      endif()
      if(counter GREATER 0)
        math(EXPR mod "${counter} % 16")
        if(mod EQUAL 0)
          string(APPEND array_data "\n    ")
        endif()
      endif()
      string(APPEND array_data "0x${byte}")
      math(EXPR counter "${counter} + 1")
    endforeach()

    # Generate header file
    file(WRITE "${output_header}"
"// Auto-generated by embed_binary
// Source file: ${filename}

#ifndef ${namespace_prefix}_${var_name}_H
#define ${namespace_prefix}_${var_name}_H

#include <cstddef>

namespace ${args_NAMESPACE} {

extern const unsigned char ${var_name}_data[];
extern const std::size_t ${var_name}_size;

} // namespace ${args_NAMESPACE}

#endif // ${namespace_prefix}_${var_name}_H
")

    # Generate source file
    file(WRITE "${output_source}"
"// Auto-generated by embed_binary
// Source file: ${filename}

#include \"${var_name}.h\"

namespace ${args_NAMESPACE} {

const unsigned char ${var_name}_data[] = {
    ${array_data}
};

const std::size_t ${var_name}_size = ${data_length};

} // namespace ${args_NAMESPACE}
")

    list(APPEND generated_sources "${output_source}")
    list(APPEND generated_headers "${output_header}")
  endforeach()

  # Create library target
  add_library(${args_TARGET} STATIC
    ${generated_sources}
    ${generated_headers}
  )

  # Add include directory
  target_include_directories(${args_TARGET}
    PUBLIC
      "$<BUILD_INTERFACE:${args_OUTPUT_DIR}>"
  )

  # Organize in IDE
  source_group("Generated Files" FILES ${generated_sources} ${generated_headers})

  message(STATUS "embed_binary: Created target ${args_TARGET} with ${list(LENGTH args_FILES)} embedded files")
endfunction()
